# bpy.data Guide for Movie Director Addon

## Overview

`bpy.data` is the gateway to all data in a Blender file. For the Movie Director addon, it's essential for creating, managing, and organizing generative assets including characters, styles, scenes, and generated media files.

## Core Data Collections

### Essential Collections for Movie Production
```python
# Objects - Characters, Styles, Locations, Shots (as Empty objects)
bpy.data.objects          # All scene objects
bpy.data.collections      # Scene organization

# Generated content references
bpy.data.movieclips       # Video clips generated by agents
bpy.data.sounds           # Audio files generated by Sound Designer
bpy.data.images           # Reference images and generated frames

# Asset data
bpy.data.materials        # Generated or referenced materials
bpy.data.node_groups      # Reusable generation workflows
bpy.data.texts            # Scripts and generated content
```

### Specialized Collections
```python
# For advanced features
bpy.data.curves           # Camera paths for 3D reprojection
bpy.data.cameras          # Virtual cameras for scene composition
bpy.data.scenes           # Multiple production contexts
bpy.data.worlds           # Environment settings
```

## Movie Director Data Patterns

### Asset Creation Patterns
```python
def create_character_asset(name, reference_images=None, lora_path=None):
    """Create a character asset using bpy.data"""
    # Create Empty object to hold character data
    character_obj = bpy.data.objects.new(name, None)
    character_obj.empty_display_type = 'PLAIN_AXES'
    character_obj.empty_display_size = 2.0
    
    # Set custom properties for character data
    character_obj.movie_director.asset_type = 'character'
    character_obj.movie_director.character_name = name
    if reference_images:
        character_obj.movie_director.reference_images_path = reference_images
    if lora_path:
        character_obj.movie_director.character_lora_path = lora_path
    
    # Add to scene
    bpy.context.scene.collection.objects.link(character_obj)
    
    return character_obj

def create_shot_asset(shot_number, scene_name, dialogue=""):
    """Create a shot asset with proper data organization"""
    shot_name = f"Shot_{shot_number:03d}"
    
    # Create shot object
    shot_obj = bpy.data.objects.new(shot_name, None)
    shot_obj.empty_display_type = 'IMAGE'
    shot_obj.empty_display_size = 5.0
    
    # Configure shot properties
    shot_obj.movie_director.asset_type = 'shot'
    shot_obj.movie_director.shot_number = shot_number
    shot_obj.movie_director.dialogue = dialogue
    shot_obj.movie_director.scene_name = scene_name
    
    # Organize in collection
    scene_collection = get_or_create_scene_collection(scene_name)
    scene_collection.objects.link(shot_obj)
    
    return shot_obj
```

### Data Organization Patterns
```python
def organize_production_data():
    """Create organized collection structure for film production"""
    scene = bpy.context.scene
    
    # Main production collections
    collections = {
        'Characters': bpy.data.collections.new("Characters"),
        'Styles': bpy.data.collections.new("Styles"),
        'Locations': bpy.data.collections.new("Locations"),
        'Scenes': bpy.data.collections.new("Scenes"),
        'Generated_Media': bpy.data.collections.new("Generated_Media")
    }
    
    # Link to scene
    for collection in collections.values():
        scene.collection.children.link(collection)
    
    return collections

def get_or_create_scene_collection(scene_name):
    """Get existing scene collection or create new one"""
    collection_name = f"Scene_{scene_name}"
    
    # Check if collection exists
    if collection_name in bpy.data.collections:
        return bpy.data.collections[collection_name]
    
    # Create new scene collection
    scene_collection = bpy.data.collections.new(collection_name)
    
    # Link to Scenes master collection
    if "Scenes" in bpy.data.collections:
        bpy.data.collections["Scenes"].children.link(scene_collection)
    else:
        bpy.context.scene.collection.children.link(scene_collection)
    
    return scene_collection
```

### Safe Data Access
```python
def safe_get_object(name):
    """Safely get object by name"""
    return bpy.data.objects.get(name)

def safe_get_collection(name):
    """Safely get collection by name"""
    return bpy.data.collections.get(name)

def find_character_assets():
    """Find all character assets in the scene"""
    characters = []
    for obj in bpy.data.objects:
        if (hasattr(obj, 'movie_director') and 
            obj.movie_director.asset_type == 'character'):
            characters.append(obj)
    return characters

def find_shots_in_scene(scene_name):
    """Find all shots belonging to a specific scene"""
    shots = []
    for obj in bpy.data.objects:
        if (hasattr(obj, 'movie_director') and 
            obj.movie_director.asset_type == 'shot' and
            obj.movie_director.scene_name == scene_name):
            shots.append(obj)
    return sorted(shots, key=lambda x: x.movie_director.shot_number)
```

## Data Management for Generated Content

### Media File Integration
```python
def import_generated_video(video_path, shot_obj):
    """Import generated video and link to shot"""
    # Import video as movie clip
    try:
        movie_clip = bpy.data.movieclips.load(video_path)
        
        # Link to shot object
        shot_obj.movie_director.generated_video_path = video_path
        shot_obj.movie_director.video_clip = movie_clip.name
        
        # Set up empty display to show video thumbnail
        shot_obj.empty_display_type = 'IMAGE'
        if movie_clip.has_proxy:
            shot_obj.data = movie_clip.proxy
        
        return movie_clip
    except Exception as e:
        print(f"Failed to import video {video_path}: {e}")
        return None

def import_generated_audio(audio_path, shot_obj):
    """Import generated audio and link to shot"""
    try:
        sound = bpy.data.sounds.load(audio_path)
        
        # Link to shot object
        shot_obj.movie_director.generated_audio_path = audio_path
        shot_obj.movie_director.audio_clip = sound.name
        
        return sound
    except Exception as e:
        print(f"Failed to import audio {audio_path}: {e}")
        return None

def import_reference_images(image_paths, asset_obj):
    """Import reference images for character or style assets"""
    imported_images = []
    
    for image_path in image_paths:
        try:
            image = bpy.data.images.load(image_path)
            imported_images.append(image)
            
            # Set as empty display image for first reference
            if len(imported_images) == 1:
                asset_obj.empty_display_type = 'IMAGE'
                asset_obj.data = image
                
        except Exception as e:
            print(f"Failed to import image {image_path}: {e}")
    
    return imported_images
```

### Data Cleanup and Optimization
```python
def cleanup_orphaned_data():
    """Remove orphaned data blocks to optimize file size"""
    # Remove orphaned meshes, materials, textures, etc.
    for collection in [bpy.data.meshes, bpy.data.materials, 
                      bpy.data.textures, bpy.data.images]:
        for item in collection:
            if item.users == 0:
                collection.remove(item)

def cleanup_temporary_data():
    """Remove temporary data created during generation"""
    # Remove objects marked as temporary
    temp_objects = [obj for obj in bpy.data.objects 
                   if obj.name.startswith("temp_")]
    
    for obj in temp_objects:
        bpy.data.objects.remove(obj, do_unlink=True)
    
    # Remove temporary collections
    temp_collections = [col for col in bpy.data.collections 
                       if col.name.startswith("temp_")]
    
    for col in temp_collections:
        bpy.data.collections.remove(col)

def pack_external_data():
    """Pack all external files into .blend for portability"""
    # Pack images
    bpy.ops.file.pack_all()
    
    # Store paths to generated content
    scene = bpy.context.scene
    if hasattr(scene, 'movie_director'):
        # Store references to external generated files
        scene.movie_director.external_video_files = []
        scene.movie_director.external_audio_files = []
```

## Advanced Data Operations

### Asset Browser Integration
```python
def mark_as_asset_browser_item(obj, catalog_name="Movie Director"):
    """Mark object for Asset Browser with proper metadata"""
    # Mark as asset
    obj.asset_mark()
    
    # Generate preview
    obj.asset_generate_preview()
    
    # Set metadata
    obj.asset_data.description = f"Generated {obj.movie_director.asset_type}"
    
    # Add tags
    asset_type = obj.movie_director.asset_type
    obj.asset_data.tags.new(asset_type)
    obj.asset_data.tags.new("generative")
    obj.asset_data.tags.new("movie_director")
    
    # Assign to catalog
    catalog_id = get_or_create_asset_catalog(catalog_name)
    if catalog_id:
        obj.asset_data.catalog_id = catalog_id

def get_or_create_asset_catalog(catalog_name):
    """Get or create asset catalog for organization"""
    # Asset catalogs are managed through bpy.context.asset_library_ref
    # This would need proper implementation based on Blender's asset system
    pass
```

### Data Validation and Integrity
```python
def validate_production_data():
    """Validate data integrity for film production"""
    errors = []
    warnings = []
    
    # Check for required collections
    required_collections = ['Characters', 'Styles', 'Scenes']
    for col_name in required_collections:
        if col_name not in bpy.data.collections:
            errors.append(f"Missing required collection: {col_name}")
    
    # Validate character assets
    characters = find_character_assets()
    for char in characters:
        if not char.movie_director.character_name:
            warnings.append(f"Character {char.name} missing name property")
        
        # Check for required files
        lora_path = char.movie_director.character_lora_path
        if lora_path and not os.path.exists(lora_path):
            warnings.append(f"Character {char.name} LoRA file not found: {lora_path}")
    
    # Validate shot sequence integrity
    scenes = {}
    for obj in bpy.data.objects:
        if (hasattr(obj, 'movie_director') and 
            obj.movie_director.asset_type == 'shot'):
            scene_name = obj.movie_director.scene_name
            shot_number = obj.movie_director.shot_number
            
            if scene_name not in scenes:
                scenes[scene_name] = []
            scenes[scene_name].append(shot_number)
    
    # Check for shot number gaps
    for scene_name, shot_numbers in scenes.items():
        shot_numbers.sort()
        for i, shot_num in enumerate(shot_numbers[1:], 1):
            if shot_num != shot_numbers[i-1] + 1:
                warnings.append(f"Scene {scene_name} has shot number gap: {shot_numbers[i-1]} -> {shot_num}")
    
    return errors, warnings
```

## Best Practices

### 1. Use Descriptive Names
```python
# GOOD: Descriptive names
character_obj = bpy.data.objects.new("Hero_Character", None)
style_obj = bpy.data.objects.new("Cyberpunk_Style", None)

# AVOID: Generic names
obj1 = bpy.data.objects.new("Object", None)
obj2 = bpy.data.objects.new("Object.001", None)
```

### 2. Check Existence Before Creation
```python
def safe_create_collection(name):
    """Create collection only if it doesn't exist"""
    if name in bpy.data.collections:
        return bpy.data.collections[name]
    else:
        return bpy.data.collections.new(name)
```

### 3. Use Context Managers for Data Operations
```python
class DataOperationContext:
    """Context manager for safe data operations"""
    def __init__(self):
        self.created_objects = []
        self.created_collections = []
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type:  # If exception occurred, cleanup
            self.cleanup_created_data()
    
    def create_object(self, name, object_data=None):
        obj = bpy.data.objects.new(name, object_data)
        self.created_objects.append(obj)
        return obj
    
    def cleanup_created_data(self):
        for obj in self.created_objects:
            if obj.name in bpy.data.objects:
                bpy.data.objects.remove(obj, do_unlink=True)
```

### 4. Efficient Data Queries
```python
# Use dictionary comprehensions for fast lookups
char_lookup = {obj.movie_director.character_name: obj 
               for obj in bpy.data.objects 
               if hasattr(obj, 'movie_director') and 
                  obj.movie_director.asset_type == 'character'}

# Cache frequently accessed data
class DataCache:
    def __init__(self):
        self._characters = None
        self._shots = None
    
    @property
    def characters(self):
        if self._characters is None:
            self._characters = find_character_assets()
        return self._characters
    
    def invalidate(self):
        self._characters = None
        self._shots = None
```

This data guide ensures efficient and organized management of all generative assets and media files within the Movie Director addon.